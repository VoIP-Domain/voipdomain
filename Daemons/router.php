#!/usr/bin/php -q
<?php
/**   ___ ___       ___ _______     ______                        __
 *   |   Y   .-----|   |   _   |   |   _  \ .-----.--------.---.-|__.-----.
 *   |.  |   |  _  |.  |.  1   |   |.  |   \|  _  |        |  _  |  |     |
 *   |.  |   |_____|.  |.  ____|   |.  |    |_____|__|__|__|___._|__|__|__|
 *   |:  1   |     |:  |:  |       |:  1    /
 *    \:.. ./      |::.|::.|       |::.. . /
 *     `---'       `---`---'       `------'
 *
 * Copyright (C) 2016-2025 Ernani José Camargo Azevedo
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * Message router daemon. This daemon listen for events generated by Asterisk
 * servers or the administrative interface. When some event match a notification
 * entry, the event notification was made and fired.
 *
 * @author     Ernani José Camargo Azevedo <azevedo@voipdomain.io>
 * @version    1.0
 * @package    VoIP Domain
 * @subpackage Message Router Daemon
 * @copyright  2016-2025 Ernani José Camargo Azevedo. All rights reserved.
 * @license    https://www.gnu.org/licenses/gpl-3.0.en.html
 */

/**
 * Set error reporting level
 */
error_reporting ( E_ERROR);
ini_set ( "display_errors", "false");
// error_reporting ( E_ALL); ini_set ( "display_errors", "true");

/**
 * Check if script is running from CLI
 */
if ( ! defined ( "STDIN"))
{
  echo "This script must be executed from the CLI!\n";
  exit ( 1);
}

/**
 * Check if required PHP modules are available
 */
if ( ! extension_loaded ( "gearman"))
{
  echo "Your PHP must have the Gearman module loaded!\n";
  exit ( 1);
}
if ( ! extension_loaded ( "pcntl"))
{
  echo "Your PHP must have the pcntl module loaded!\n";
  exit ( 1);
}

/**
 * Include functions library
 */
require_once ( dirname ( __FILE__) . "/includes/functions.inc.php");
require_once ( dirname ( __FILE__) . "/includes/plugins.inc.php");

/**
 * Parse configuration file. You should put your configuration file OUTSIDE
 * the web server files path, or you must block access to this file at the
 * web server configuration. Your configuration would contain passwords and
 * other sensitive configurations.
 */
$_in = parse_ini_file ( "/etc/voipdomain/router.conf", true);

/**
 * Check for mandatory basic configurations (if didn't exist, set default)
 */
if ( ! array_key_exists ( "general", $_in))
{
  $_in["general"] = array ();
}
if ( ! array_key_exists ( "version", $_in["general"]))
{
  $_in["version"] = "1.0";
} else {
  $_in["version"] = $_in["general"]["version"];
  unset ( $_in["general"]["version"]);
}
if ( ! array_key_exists ( "charset", $_in["general"]))
{
  $_in["general"]["charset"] = "UTF-8";
}
if ( ! array_key_exists ( "language", $_in["general"]))
{
  $_in["general"]["language"] = "en_US";
}
$_in["keys"] = array ();

/**
 * Configure locale and encoding
 */
mb_internal_encoding ( $_in["general"]["charset"]);
setlocale ( LC_ALL, $_in["general"]["language"] . "." . $_in["general"]["charset"]);

/**
 * Show software version header
 */
echo chr ( 27) . "[1;37mVoIP Domain Message Router Daemon" . chr ( 27) . "[1;0m v" . $_in["version"] . "\n";
echo "\n";

/**
 * Process parameters
 */
$debug = false;
for ( $x = 1; $x < $argc; $x++)
{
  switch ( $argv[$x])
  {
    case "--debug":
    case "-d":
      $debug = true;
      break;
    case "--help":
    case "-h":
      echo "Usage: " . basename ( $argv[0]) . " [--help|-h] [--debug|-d]\n";
      echo "  --help|-h:    Show this help information\n";
      echo "  --debug|-d:   Enable debug messages (do not fork the daemon)\n";
      exit ();
      break;
    default:
      echo "ERROR: Invalid parameter \"" . $argv[$x] . "\"!\n";
      exit ( -1);
      break;
  }
}

/**
 * Validate MySQL session
 */
if ( ! is_array ( $_in["mysql"]))
{
  echo "Error: Cannot find \"mysql\" session at configuration file.\n";
  exit ( 1);
}

/**
 * Include all modules files
 */
echo "Executing: Loading modules... ";
foreach ( glob ( dirname ( __FILE__) . "/router-modules/*/router.php") as $filename)
{
  require_once ( $filename);
}
echo chr ( 27) . "[1;37mOK" . chr ( 27) . "[1;0m\n";

/**
 * Add internal event hook's
 */
framework_add_hook ( "event", "dump");
framework_add_hook ( "notifications_reload", "reload_notifications");

/**
 * Connect to MySQL database
 */
echo "Executing: Connecting to database server... ";
if ( ! $_in["mysql"]["id"] = @new mysqli ( $_in["mysql"]["hostname"] . ( ! empty ( $_in["mysql"]["port"]) ? ":" . $_in["mysql"]["port"] : ""), $_in["mysql"]["username"], $_in["mysql"]["password"], $_in["mysql"]["database"]))
{
  writeLog ( "Cannot connect to database server!", VoIP_LOG_FATAL);
}
echo chr ( 27) . "[1;37mOK" . chr ( 27) . "[1;0m\n";

/**
 * Fetch notifications database
 */
echo "Executing: Fetching notifications database... ";
reload_notifications ();
echo chr ( 27) . "[1;37mOK" . chr ( 27) . "[1;0m\n";

/**
 * Change effective UID/GID to an unprivileged user
 */
echo "Executing: Changing effective UID/GID... ";
if ( ! $uid = posix_getpwnam ( $_in["daemon"]["uid"]))
{
  writeLog ( "Cannot check for the user \"" . $_in["daemon"]["uid"] . "\"!", VoIP_LOG_FATAL);
}
if ( ! $gid = posix_getgrnam ( $_in["daemon"]["gid"]))
{
  writeLog ( "Cannot check for the group \"" . $_in["daemon"]["gid"] . "\"!", VoIP_LOG_FATAL);
}
if ( ! posix_setgid ( $gid["gid"]))
{
  writeLog ( "Cannot change to GID " . $gid["gid"] . " \"" . $_in["daemon"]["gid"] . "\"!", VoIP_LOG_FATAL);
}
if ( ! posix_setuid ( $uid["uid"]))
{
  writeLog ( "Cannot change to UID " . $uid["uid"] . " \"" . $_in["daemon"]["uid"] . "\"!", VoIP_LOG_FATAL);
}
echo chr ( 27) . "[1;37mOK" . chr ( 27) . "[1;0m\n";

/**
 * If possible, change process name
 */
if ( extension_loaded ( "proctitle"))
{
  setproctitle ( "VoIP Domain Message Router daemon");
}

/**
 * Show start of operations message
 */
echo "Everything done. Waiting for connections!\n\n";

/**
 * Log system initialization
 */
writeLog ( "VoIP Domain Message Router daemon initialized.");
echo "\n";

/**
 * Fork process to daemon mode (except if in debug mode)
 */
error_reporting ( E_ERROR);
set_time_limit ( 0);
ob_implicit_flush ();
if ( function_exists ( "pcntl_async_signals"))
{
  pcntl_async_signals ( true);
} else {
  declare ( ticks = 1);
}
$_in["mainpid"] = posix_getpid ();
if ( ! $debug)
{
  $pid = pcntl_fork ();
  if ( $pid == -1)
  {
    writeLog ( "Cannot fork process!", VoIP_LOG_FATAL);
  }
  if ( $pid)
  {
    exit ();
  }
  posix_setsid ();
}

/**
 * Start Gearman worker
 */
while ( true)
{
  /**
   * Connect to gearman servers
   */
  $gm = new GearmanWorker ();
  $gm->addServer ( ( $_in["gearman"]["hostname"] ? $_in["gearman"]["hostname"] : "127.0.0.1"), ( $_in["gearman"]["port"] ? $_in["gearman"]["port"] : 4730));

  /**
   * Register worker functions
   */
  foreach ( $_plugins["hooks"] as $hook => $function)
  {
    $gm->addFunction ( $hook, "gearman_event");
  }

  /**
   * Loop waiting for work!
   */
  while ( @$gm->work ()) {}

  /**
   * If exited loop, all gearman servers was gone!
   */
  writeLog ( "Gearman servers disconnected! Retrying in 5 seconds.", VoIP_LOG_WARNING);
  unset ( $gm);
  sleep ( 5);
}

/**
 * Gearman framework hook system wrapper.
 *
 * @global array $_in Framework global configuration variable
 * @param $job object Gearman Job object.
 * @return (mixed) Hook output.
 */
function gearman_event ( $job)
{
  global $_in;

  // Dump event if debbug enabled
  if ( $_in["general"]["debug"])
  {
    echo "Event \"" . $job->functionName () . "\" received: ";
  }

  // Get workload
  $workload = json_decode ( $job->workload (), 1);

  // Call job hook
  $result = framework_call ( $job->functionName (), $workload, false, array ( "events" => array (), "return" => ""));

  // Check for notification events:
  foreach ( $result["events"] as $event)
  {
    foreach ( $_in["Notifications"] as $notification)
    {
      if ( $notification["Event"] == $event["event"])
      {
        // Validate rules:
        if ( sizeof ( $notification["Rules"]) != 0 && check_rules ( $notification["Rules"], $event["parameters"]))
        {
          echo "Notification event match!\n";
        }
      }
    }
  }

  // Return event data:
  return $result["return"];
}

function dump ( $buffer, $parameters)
{
  print_r ( $parameters);
  echo "\n";
}

/**
 * Function to check notification rules logic agains event parameters. This
 * function was called recursively to process sub logic rules.
 *
 * @param array &$rules Rules array. Function will append "result" boolean to
 *                      each rule and to array root with overall logic result.
 * @param array $parameters Array containing the event parameters.
 * @return boolean Result of final rule logic.
 */
function check_rules ( &$rules, $parameters)
{
  foreach ( $rules as $key => $value)
  {
    if ( $key == "rules")
    {
      foreach ( $value as $id => $rule)
      {
        if ( array_key_exists ( "rules", $rule))
        {
          check_rules ( $rules[$key][$id], $parameters);
          continue;
        }
        switch ( $rule["operator"])
        {
          case "equal":
          case "not_equal":
            switch ( $rule["type"])
            {
              case "string":
              case "time":
                $rules[$key][$id]["result"] = (string) $parameters[$rule["field"]] == (string) $rule["value"];
                break;
              case "number":
              case "integer":
              case "date":
              case "datetime":
                $rules[$key][$id]["result"] = (int) $parameters[$rule["field"]] == (int) $rule["value"];
                break;
              case "double":
                $rules[$key][$id]["result"] = (float) $parameters[$rule["field"]] == (float) $rule["value"];
                break;
              case "boolean":
                $rules[$key][$id]["result"] = (boolean) $parameters[$rule["field"]] == (boolean) $rule["value"];
                break;
            }
            break;
          case "in":
          case "not_in":
            $rules[$key][$id]["result"] = in_array ( $parameters[$rule["field"]], $rule["value"], true);
            break;
          case "less":
            $rules[$key][$id]["result"] = $parameters[$rule["field"]] < $rule["value"][0];
            break;
          case "less_or_equal":
            $rules[$key][$id]["result"] = $parameters[$rule["field"]] <= $rule["value"][0];
            break;
          case "greater":
            $rules[$key][$id]["result"] = $parameters[$rule["field"]] > $rule["value"][0];
            break;
          case "greater_or_equal":
            $rules[$key][$id]["result"] = $parameters[$rule["field"]] >= $rule["value"][0];
            break;
          case "between":
          case "not_between":
            $rules[$key][$id]["result"] = $parameters[$rule["field"]] >= $rule["value"][0] && $parameters[$rule["field"]] <= $rule["value"][1];
            break;
          case "begins_with":
          case "not_begins_with":
            $rules[$key][$id]["result"] = substr ( $parameters[$rule["field"]], 0, strlen ( $rule["value"])) == $rule["value"];
            break;
          case "contains":
          case "not_contains":
            $rules[$key][$id]["result"] = strpos ( $parameters[$rule["field"]], $rule["value"]) !== false;
            break;
          case "ends_with":
          case "not_ends_with":
            $rules[$key][$id]["result"] = substr ( $parameters[$rule["field"]], strlen ( $rule["value"]) * -1) == $rule["value"];
            break;
          case "is_empty":
          case "is_not_empty":
            $rules[$key][$id]["result"] = $parameters[$rule["field"]] === "";
            break;
          case "is_null":
          case "is_not_null":
            $rules[$key][$id]["result"] = is_null ( $parameters[$rule["field"]]);
            break;
        }
        if ( substr ( $rule["operator"], 0, 4) == "not_" || $rule["operator"] == "is_not_empty" || $rule["operator"] == "is_not_null")
        {
          $rules[$key][$id]["result"] = ! $rules[$key][$id]["result"];
        }
      }
    }
  }

  // Check logic
  switch ( $rules["condition"])
  {
    case "OR":
      $result = false;
      foreach ( $rules["rules"] as $rule)
      {
        if ( $rule["result"])
        {
          $result = true;
          break;
        }
      }
      break;
    case "AND":
      $result = true;
      foreach ( $rules["rules"] as $rule)
      {
        if ( ! $rule["result"])
        {
          $result = false;
          break;
        }
      }
      break;
  }
  if ( array_key_exists ( "not", $rules) && $rules["not"] == true)
  {
    $result = ! $result;
  }
  $rules["result"] = $result;

  return $result;
}

/**
 * Function to reload notifications from database.
 *
 * @global array $_in Framework Main configuration variable
 * @param void
 * @return boolean
 */
function reload_notifications ()
{
  global $_in;

  // Check if database connection are alive
  mysql_check ();

  // Fetch data
  if ( ! $result = @$_in["mysql"]["id"]->query ( "SELECT * FROM `Notifications`"))
  {
    writeLog ( "Cannot fetch notifications from database!", VoIP_LOG_WARNING);
    return false;
  }

  // Populate notifications variable
  $_in["Notifications"] = array ();
  while ( $notification = $result->fetch_assoc ())
  {
    $notification["Headers"] = json_decode ( $notification["Headers"], true);
    $notification["Filters"] = json_decode ( $notification["Filters"], true);
    $notification["Variables"] = json_decode ( $notification["Variables"], true);
    $_in["Notifications"][] = $notification;
  }

  return true;
}
?>
